package com.mouzu.project.interview.java.jvm;

public class JvmInfo {
    /**
     * -》java对象分配原则：
     * 1、尝试进行栈上分配（线程私有小对象，对象无逃逸，并且支持标量替换），栈上分配的对象会随着方法结束栈帧弹出而消亡，无需等到GC去清理
     * 2、栈上分配失败，如果是大对象，则直接分配到堆中Old区；
     * 3、如果是小对象，优先进行线程私有本地分配（Thread Local Allocation Buff（TLAB），文末解释）
     * 4、线程私有本地分配失败，则分配在堆中Young区中的Eden区
     *
     * -》为啥优先进行线程私有本地分配TLAB：
     * 在Eden区中，由于空间是线程共享，会导致多个线程同时去竞争Eden区中位置而降低效率。为了减少这种情况，
     * 每个线程会在Eden区中获取一块私有空间（默认1%，JVM参数可调），线程上的私有小对象会优先分配到这里，避免多个线程同时竞争一个位置，提高效率
     *
     * -》java类的生命周期
     * 1、加载
     *      通过类名获取类的二进制字节流是通过类加载器来完成的。其加载过程使用“双亲委派模型”
     * 2、验证（链接）
     *      当一个类被加载之后，必须要验证一下这个类是否合法，比如这个类是不是符合字节码的格式、变量与方法是不是有重复、数据类型
     *      是不是有效、继承与实现是否合乎标准等等。总之，这个阶段的目的就是保证加载的类是能够被jvm所运行
     * 3、准备（链接）
     *      为类变量（静态变量）在方法区分配内存，并设置零值。注意：这里是类变量，不是实例变量，实例变量是对象分配到堆内存时根据运行时动态生成的
     * 4、解析
     *      把常量池中的符号引用解析为直接引用：根据符号引用所作的描述，在内存中找到符合描述的目标并把目标指针指针返回
     * 5、初始化（链接）
     *      按照顺序自上而下运行类中的变量赋值语句和静态语句，先父类
     *
     *  -》java对象创建过程
     *  即类的实例化过程。在java类经过加载、链接和初始化之后，实例化过程会在堆中开辟内存，将一些非静态的方法、变量存放在里面。
     *  在程序执行的过程中，可以创建多个对象，既多次实例化。每次实例化都会开辟一块新的内存。（就是调用构造函数）
     *
     *  -》java对象的结构
     *  1、对象头 ：由MarkWord， 指向类的指针，和数组长度组成，数组长度仅数组对象有
     *          a、MarkWord内部包含了，hashcode，gc分代年龄，锁标识状态，当前偏向线程id，线程持有的锁
     *          b、指向类的指针，记录了对象类在方法区或者元数据空间的位置
     *          c、数组长度只有数组对象持有，长度都是32个字节
     *  2、实例数据
     *          对象的属性以及属性值
     *  3、对齐填充
     *          jvm要求对象的大小应是8bit的倍数，仅仅用于填充没有别的含义
     *
     * -》jvm如何判断对象可被回收
     * 1、引用计数器算法
     *      原理：给对象添加一个引用计数器，每当有一个地方引用它时，计数器的值就会加1；当引用失效时，计数器就会减1；
     *          在任何时刻计数器的值为0的对象就是不可能再被使用的，也就是被回收的对象
     *      缺点：无法解决对象之间循环引用的问题，对于循环引用的对象，无法进行回收
     *
     * 2、根可达性算法
     *
     * -》java堆的分区
     * 1、新生代：eden区和survivor区
     * 2、老年代
     *
     * -》什么情况下对象会进入到老年代
     * 1、大对象直接进入老年代
     * 2、长期存活的对象进入老年代（年龄默认为15）
     * 3、动态年龄判断并进入老年代
     *      如果在Survivor空间中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，
     *      无需达到MaxTensuringThreshold的要求年龄
     *
     * -》什么时候会触发Minor GC和FULL GC
     * Minor GC触发时机：Eden 区没有足够的空间分配给新创建的对象
     *         回收算法：标记-复制
     *
     * FULL GC触发时机：
     *          1、老年代空间不足
     *          2、方法区空间不足
     *          3、Minor GC 引发 Full GC
     *
     * -》为啥Minor GC 引发 Full GC？
     *  因为JVM老年代有一套空间担保机制，在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果小于则
     *  进行Full GC。
     *
     *  -》方法区、永久代和元空间的关系
     *  Metaspace（元空间）和 PermGen（永久代）类似，都是对 JVM规范中方法区的一种落地实现，元空间与永久代之间最大的区别在于：
     *  元空间并不在虚拟机中，而是使用本地内存
     *
     *  -》为啥java 8用元空间取代永久代
     *  1、字符串存在永久代中，容易出现性能问题和内存溢出
     *  2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出
     *  3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低
     *
     *  -》jvm中堆大小设置
     *  一个小知识点：jvm的参数大部分都是-XX:+/-{KEY}或者是-XX:key=value形式，为什么出现-Xms,-Xmx,-Xss的命令？
     * 其实-Xms等于-XX:InitialHeapSize；-Xmx 等同于-XX:MaxHeapSize；而-Xss等同于-XX:ThreadStackSize；
     * 因此其实-X命令等于-XX命令。
     * 另外多说一句，如果我们自己不设置的话 -Xms默认为系统内存的1/64，-Xmx默认为系统内存的1/4。
     *
     * -》如何排查OOM
     * 1、jvm参数方式-XX:+PrintGCDetails 查看内存和gc日志情况
     * 2、另一种方式就是jvm参数，比如-XX:+HeapDumpOnOutOfMerroryError和配合-XX:HeapDumpPath的使用，会在OOM异常时导出heapDump文件
     *
     * -》如何解决OOM
     * 1、简单粗暴，堆空间不够那就增加堆空间的大小，把-Xms和-Xmx扩大
     * 2、查看代码是否因为设计原因，导致很多垃圾对象产生。比如某些对象能不能不用每次都新建，而使用单例模式。对于长生命周期对象对象后续不用了，
     * object=null可以辅助GC
     *
     */
}
