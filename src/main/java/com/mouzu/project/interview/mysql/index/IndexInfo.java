package com.mouzu.project.interview.mysql.index;

public class IndexInfo {
    /**
     * -》导致索引失效的原因：
     * 1、使用select *（导致覆盖索引失）
     * 2、索引列有使用函数
     * 3、like语句左边包含%
     * 4、联合索引不满足最左匹配原则
     * 5、使用or关键字
     *
     * -》CHAR和VARCHAR的区别
     * 1、CHAR是固定长度，VARCHAR是可变长度
     * 2、由于CHAR是固定长度，存取速度还是要比varchar要快得多，方便程序的存储与查找，varchar则刚好相反，以时间换空间
     * 3、对 char 来说，最多能存放的字符个数 255，和编码无关;而 varchar 呢，最多能存放 65532 个字符。
     *      varchar的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是 65,532字节。
     *
     * -》BLOB和TEXT有什么区别？
     * BLOB是一个二进制数据类型，可以容纳可变数量的数据。有四种类型的BLOB：TINYBLOB、BLOB、MEDIUMBLO和 LONGBLOB
     * TEXT是保存字符数据，四种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT
     *
     * -》mysql中存在哪些锁
     * 1、按锁的粒度可分为表级锁、页级锁和行级锁（innodb）
     * 2、按锁的共享策略可分为共享锁S、排他锁X、意向共享锁IS和意向排他锁IX
     * (如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。)
     * 为了解决在RR级别一致性锁定读产生的幻读，还加入了next-key lock，它是记录锁和间隙锁的集合
     *
     * -》mysql什么情况下存在死锁
     *  死锁: 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去
     *      关键点是两个(或以上)的Session加锁的顺序不一致
     *  比如：
     *     session1:                                        session2:
     *     1、select * from t where id = 9 for update;
     *                                                      2、select * from t where id < 20 for update;
     *     3、insert into t values(7,'','',now());
     *
     *  描述：当前表有一条id=9的记录，session1通过一致性锁定读锁住id=9的记录（即session1持有id=9的记录锁），此时session2通过
     *      一致性锁定读锁住id<20的记录（即session持有1到8的间隙锁gap lock），之后session1想往表里插入一条id=7的记录，这时
     *      session1和session2由于互相持有对方的锁而造成死锁
     *
     * -》导致死锁的四大条件
     * 1、请求资源互斥
     * 2、占有且保持
     * 3、不可被剥夺
     * 4、循环等待
     *
     * -》如何尽量避免死锁发生
     * 1、在主键等值更新的时候，尽量先查询数据库中是否有没有满足的条件，如果没有就不用更新，存在才更新
     * 2、尽量使用主键更新数据，因为主键是唯一索引，在等值查询能查看到数据的情况下，只会产生记录锁，不会产生间隙锁，
     *    这样产生的死锁概率就减少了，如果是范围查询一样产生间隙锁
     * 3、在允许幻读和不可重复度的情况下，尽量使用RC的隔离级别，避免gap lock造成的死锁，因为产生死锁经常都跟间隙锁有关，
     *      间隙锁的存在本身也是在RR隔离级别来解决幻读的一种措施
     *
     * -》为啥要建立索引
     * 当在非常大的表中进行查询，如果数据库进行全表遍历的话那么速度是会非常慢的，而我们的索引则可以建立一个b+树的结构，
     * 可以自上而下的去进行查询（有点像二分查找），可以在一定程度避免走全表查询，这样查询的速度是非常快的；
     *
     * -》哪些情况适合建立索引？
     * 1、频繁作为where条件语句查询的字段
     * 2、关联字段需要建立索引
     * 3、排序字段可以建立索引（因为b+树结构的索引是天然有序的）
     * 4、统计字段可以建立索引，例如count(),max()
     *      因为索引是天然聚合的，就是存放在b+树的数据是已经去重的数据了，存储的数据还是比较紧凑的，那么通过B+树的双向指针可以更快的找到
     *      要统计的数据，而且在加了索引的列的统计的时候MySQL是不会产生中间表来专门去重了，可以减少不必要的性能开销；
     *      （在没有索引的列的统计，分组 的SQL语句中，MySQL都是会创建临时表来存储数据的）
     *
     * -》哪些情况下不适合建索引？
     * 1、频繁更新的字段不适合建立索引
     * 2、参与列计算的列不适合建索引（索引失效）
     * 3、表数据可以确定比较少的不需要建索引
     * 4、数据重复且分布比较均匀的的字段不适合建索引，因为说不定你对这种索引字段的查询的速度还没有全表扫描快，例如性别，真假值
     * 5、where条件中用不到的字段不适合建立索引
     *
     * -》为什么索引是使用B+树？
     * 1、因为b+树是把数据都存放在叶子节点中的（在innodb存储引擎中一个b+树的节点是 一页(16k)），那么在固定大小的容量中
     *    B+树的非叶子节点中就可以存放更多的索引列数据，也就意味着B+树的非叶子节点存储的数据的范围就会更大，那么树的层次就会更少，IO次数也就会更少；
     * 2、b+树的叶子节点维护了一个双向链表，它更有利于范围查询
     *
     * -》mysql性能调优
     * 1、表结构与索引
     *      分库分表、读写分离、为字段选择合适的数据类型、适当的反范式设计、为查询操作创建必要的索引
     * 2、sql语句优化
     *      通过慢查询分析需要优化的sql、利用explain分析sql的执行计划
     * 3、mysql参数优化
     *      设置buffer_bool的大小，官方建议是占总内存的50%-70%左右
     *      设置刷盘策略平衡好数据安全性和性能的关系
     *
     *
     */
}
