package com.mouzu.project.interview.mysql.transaction;

public class TransactionInfo {

    /**
     * mysql事务
     *
     * MVCC的理解
     * MVCC是多版本并发控制，主要作用是提高数据库的并发能力。数据库的并发包含读读操作，读写操作和写写操作。读读操作无线程安全问题，读写操作存在
     * 事务隔离性问题，具体表现为脏读、幻读和不可重复读；写写操作会出现数据更新丢失的问题。而MVCC就是解决读写操作的事务隔离性问题，
     * 通过给事务分配一个单向增长的时间戳，将每个数据更改保存一个版本，将版本和时间戳关联，每次读操作只读事务开启前的数据库快照，并且读时不用阻塞
     * 写操作，提高并发能力。
     *
     * InnoDB 对 MVCC 的实现
     * MVCC 的实现依赖于：隐藏字段、Read View、undo log。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，
     * 如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，
     * 用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改#
     *
     * 隐藏字段
     * 在内部，InnoDB 存储引擎为每行数据添加了三个 隐藏字段
     * DB_TRX_ID（6字节）：表示最后一次插入或更新该行的事务 id。此外，delete 操作在内部被视为更新，
     *              只不过会在记录头 Record header 中的 deleted_flag 字段将其标记为已删除
     * DB_ROLL_PTR（7字节） 回滚指针，指向该行的 undo log 。如果该行未被更新，则为空
     * DB_ROW_ID（6字节）：如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来生成聚簇索引
     *
     * Read View:主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务”
     *
     * RC 和 RR 隔离级别下 MVCC 的差异:
     * 在事务隔离级别 RC 和 RR （InnoDB 存储引擎的默认事务隔离级别）下，InnoDB 存储引擎使用 MVCC（非锁定一致性读），
     * 但它们生成 Read View 的时机却不同;
     * 在 RC 隔离级别下的 每次select 查询前都生成一个Read View (m_ids 列表)
     * 在 RR 隔离级别下只在事务开始后 第一次select 数据前生成一个Read View（m_ids 列表）
     *
     * 如果我们发现一条Sql执行特别慢 我们该怎么去处理
     * 1、我们先观察服务器的状态情况看是否是在周期性的波动情况，如果是那么看加缓存能不能解决掉
     * 2、如果不能解决那么我们开启慢查询，分析慢查询的语句。看是SQL的执行时间长问题，还是SQL语句的等待过长原因。
     * 3、如果是等待过长就调优服务器的参数，如果是SQL语句的原因那么我们就优化SQL语句，比如加索引优化啊数据库表的设计优化
     * 4、如果上面还是不能解决，看SQL查询是否达到了瓶颈，如果是就读写分离（主从架构）分库分表（垂直分表，垂直分库，水平分表）
     * 开启慢查询日志参数 set global slow_query_log='ON';
     * 查询有多少条慢查询的记录 SHOW GLOBAL STATUS LIKE '%Slow_queries%';
     *
     * -》CAP理论和BASE理论定义
     *  CAP理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项.
     *      一致性:所有节点在同一时间的数据完全一致
     *      可用性:服务在正常时间内一直可用
     *      分区容错性:系统在遇到某节点或者网络分区故障的时候,仍然能够对外满足可用性或一致性的服务.
     *   分布式系统中满足AP的样例:Eureka
     *      在任何时间都可用,但是可能有数据不一致的情况.
     *   分布式系统中满足CP的样例:zookeeper
     *      满足数据的最终一致性,但是在leader选举过程中不可用
     *
     *  BASE理论：基于CAP理论逐步演化而来的，是CP（强一致性）和AP（强可用性）权衡的结果,核心思想是：即使无法做到强一致性，
     *  但每个应用都可以根据自身业务特点采用适当的方式来使系统达到最终一致性
     *      Basically Available（基本可用）
     *      Soft state（软状态）
     *          数据同步允许一定的延迟
     *      Eventually consistent（最终一致性）
     *
     *-》分布式事务的解决方案
     * 1、分布式事务的理解：分布式事务指的是操作在多个相互隔离的物理节点上进行
     * 2、产生问题：事务数据的一致性问题(解决方案本质是保障不同数据库的数据一致性)
     * 3、基于CAP定理和BASE理论，分布式事务问题有强一致性方案和弱一致性方案。
     * 强一致性方案：通过第三方事务管理器来协调多个节点的事务性，保证每一个节点的事务达到同时成功或失败
     *            比如X/OPEN DTP模型提供的XA协议，基于2PC或3PC的方式去实现
     *            缺点：任一节点进行事务提交确认都可能因为网络通信延迟问题导致阻塞，从而影响到所有节点的事务提交，最终影响到系统性能和用户体验
     *
     * 弱一致性方案：针对强一致性方案所衍生的性能和数据一致性平衡的一个方案，通过损失强一致性，允许节点数据在某一时刻不一致，但是最终所有节点的
     *              数据会达成一致，从而提升了系统的性能
     *              1、使用分布式消息队列来实现数据最终一致性
     *              2、基于TCC事务，通过演进版本的2PC去实现事务数据的最终一致性
     *              3、使用seata事务框架，提供了多种事务模型，AT模型、XA模型、Sega模型、TCC模型等等，从而实现强一致性或弱一致性
     *
     *  XA和TCC分布式事务解决方案区别
     *  XA：基于2PC，依赖数据库事务，
     *  TCC：try-confirm-cancel，不依赖数据库事务，但它的回滚补偿机制需要代码实现，所以代码侵入性较强
     *  XA存在性能问题，所以分布式事务解决方案TCC用的比较多一点
     */
}
